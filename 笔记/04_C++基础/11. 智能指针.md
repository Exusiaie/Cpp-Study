# 资源管理

RAII技术, 利用对象的生命周期来管理资源, 把资源托管给对象, 在对象调用析构函数时自动释放资源

特征:

- 在构造函数中托管资源；（在给构造函数传参时初始化资源）

- 在析构函数中释放资源；

- 一般不允许进行复制或者赋值（对象语义）；

- 提供若干访问资源的方法（如：读写文件）。

>值语义和对象语义:
>
>**值语义：可以进行复制或赋值**（两个变量的值可以相同）
>
>``` c++
>int a = 10; int b = a;  int c = 20;     
>
>c = a; //赋值
>
>int d = c; //复制
>```
>
>
>
>**对象语义：不允许复制或者赋值**
>
>（全世界不会有两个完全一样的人，程序世界中也不会有两个完全一样的对象）
>
>**对象语义的常用手段：**
>
>1. 将拷贝构造函数与赋值运算符函数设置为私有的
>2. 将拷贝构造函数与赋值运算符函数=delete
>3. 使用继承的思想，将基类的拷贝构造函数与赋值运算符函数删除（或设为私有），让派生类继承基类。

<span style=color:red;background:yellow>**RAII技术的本质：**</span>利用**栈对象**的生命周期管理资源，因为栈对象在离开作用域时候，会执行析构函数。



## 经典老番 new 和 delete做的事

当你写

```c++
T* p = new T(args…);
```

1. 编译器首先会调用全局或类自定义的 **`operator new`** 函数来分配一块足够大的、未初始化的内存。默认情况下，`operator new` 的行为类似于 `malloc`, 如果申请失败，它会抛出 `std::bad_alloc` 异常。 当然, 可以重载operator new函数

2. 当内存分配成功、返回一块原始内存区域后，`new` 会在这块内存上**就地构造**（placement new）一个 `T` 类型的对象：

    ```c++ 
    new (ptr) T(args…);
    ```

    这里的 `ptr` 就是 `operator new` 返回的地址。

    构造函数会按照你传入的参数 `args…` 执行初始化。

3. 返回对象指针

    - `new T(args…)` 整个表达式的结果是一个 `T*`，指向已经构造好的对象。
    - 这与 `malloc` 不同：`malloc` 只返回未初始化的内存块，而 `new` 保证“分配内存 + 初始化”二合一。

总之: 1. 调用operator new函数在堆上开辟空间 2. 在开辟的空间中构造对象 3. 返回对象的指针

-----

## 区分&和* 的不同用法

| 区分              | 例子           | 含义   |
| ----------------- | -------------- | ------ |
| &和某个类型在一起 | `int& r = a;`  | 引用   |
| &和某个左值在一起 | `int* p = &a;` | 取地址 |



| 区分              | 例子       | 含义     |
| ----------------- | ---------- | -------- |
| *和某个类型在一起 | `int* p;`  | 声明指针 |
| *和某个左值在一起 | `*p = 20;` | 解引用   |





## 数组版本：`new T[n]`

- 对于数组，写法是

    ```c++
    T* pArr = new T[n]();
    ```

- 过程略有区别：

    1. 分配 `n * sizeof(T)` 字节（可能还会额外存储数组长度以便析构时使用）。
    2. 调用 `n` 次 `T` 的默认构造函数。
    3. 返回指向第一个元素的指针。

- 对应的释放要用 `delete[] pArr;`，以便调用每个元素的析构函数并释放整个内存块。

- 最后加上() 以清空内容

------

当你写：

```c++
T* p = /* 来自 new 的指针 */;
delete p;
```

1. 调用p所指对象的析构函数, 执行之前被new出来的对象的析构逻辑
2. 调用内存释放函数 `operator delete`, 将堆上申请的内存释放



# 二: RAII

Resource Acquisition Is Initialization(资源获取就是初始化)

利用对象的生命周期来管理资源（内存资源、文件描述符、文件、锁等），因为当对象的生命周期结束时，会自动调用析构函数。

常见特征:

> - 在构造函数中托管资源
> - 在析构函数中释放资源
> - 禁用拷贝和赋值
> - 提供访问资源的方法

```c++
// RAII
template <class T>
class RAII_class {
public:
    RAII_class(T* data)
        :_data(data) // 1.在构造函数中托管资源, 这里是对象Point
    {

    }

    ~RAII_class() {
        if (_data) {  // 2. 在析构函数中释放资源
            delete _data;
            _data = nullptr;
        }
    }
    
    RAII_class(const RAII_class &rhs) = delete;
    RAII_class& operator=(const RAII_class& rhs) = delete;
// 3. 禁止拷贝和赋值

    // 4. 提供访问资源的方法
    T* get() const {
        return _data; // 返回指针
    }

    T* operator->() {
        return _data; // 目的是访问成员, 因此也返回指针
    }

    T& operator*() {
        return *_data; // operator*是解引用, 因此返回"解引用_data", 返回类型是T的引用
    }

private:
    T* _data; // T类型指针, 指向堆空间
};

void test(){
    RAII_class< Point > raii(new Point(777, 666)); // 这些操作和智能指针完全相同

    raii->print();
    raii.get()->print();
    (*raii).print();

}
```

<img src="D:\MarkDown\Picture\image-20250703204609881.png" alt="image-20250703204609881" style="zoom: 67%;" />





# 三:    智能指针

c++有auto, unique, shared, weak四种智能指针(自动、唯一、共享、弱引用)

## auto_ptr ( 被废弃 )

废弃原因是它并没有禁止拷贝, 在发生拷贝的时候==所有权将发生转移==导致原本的指针悬空, 无法和STL等内容进行联动

```c++
void test1() {
    int* pInt = new int(10); 
    auto_ptr<int> ap(pInt);	// 创建auto_ptr对象接管资源
    						// 虽然 pInt 仍然持有原始指针值，但从此资源的“唯一拥有者”是 ap

    auto_ptr<int> ap2(ap);  // 拷贝构造 ap2，但是auto_ptr 的拷贝构造函数并不是共享资源， 而是把所有权从 ap 转移到 ap2

    cout << "*ap:" << *ap << endl; // ERROR 段错误, ap的指针被设置为了空指针
    								// 因为所有权已经被转给 ap2，ap 内部的指针被置为 nullptr
}
```

<img src="D:\MarkDown\Picture\image-20250620210927028.png" alt="image-20250620210927028" style="zoom:67%;" />

这个例子可以看到，`auto_ptr` 的拷贝并不是“共享”资源，而是“转移”资源所有权——这也正是它后来被废弃、被更安全、更清晰的 `unique_ptr` 取代的原因。



## unique_ptr

特点:

1. 不允许复制和赋值 (这就是对象语义), 但是可以使用移动构造
2. 独享所有权

```c++
void test2() {
    unique_ptr<int> up(new int(10));
    cout << "*up:" << *up << endl;
    cout << "up.get(): " << up.get() << endl;

    // 独享所有权的智能指针，对托管的空间独立拥有
    // 拷贝构造不能被使用
    unique_ptr<int> up2 = up; // 拷贝构造, 复制操作 error
    
    unique_ptr<int> up3(new int(20)); //赋值运算符函数也被删除了, 不能被使用
    up3 = up;//赋值操作 error
}
```

3. 作为容器元素

    **方法1: 利用std::move()函数**

    unique_str指针的拷贝构造函数不可用, 但是可以移动(即从一个左值转化成一个右值)

    ```c++
    void test3(){
    	unique_ptr<Point> up(new Point(1,2)); // 栈上：up 对象持有 0x777
    	vector<unique_ptr<Point>> vec; // 栈上：vec 对象
        
    	vec.push_back(up);     // error：尝试拷贝 up（左值）, 需要使用拷贝构造函数, 调用被 delete 的拷贝构造
        vec.push_back(std::move(up); // OK, 拷贝右值, 使用移动构造函数
    }
    ```
    
    在上面的代码中, 我们先在栈上创建了一个类型为<Point>的智能指针up, 内部保存了一个原生指针(假设值为0x777) 指向堆上新建的Point(1, 2).	然后我们又在栈上创建了一个类型为 "<Point>智能指针" 的vector容器vec.	
    
    需求: <font color = red>我们想把身为左值且无法拷贝构造的unique_ptr对象存入一个容器中</font>
    
    这个时候的问题是: vec里面的元素保存在堆上, 但是up智能指针对象保存在栈上, 要想push_back只能把up指针拷贝一份去堆上, 但是up智能指针不能拷贝.	 
    
    因此解决办法是使用std::move()函数将身为左值的up智能指针转为右值, 利用移动构造函数完成拷贝赋值: 
    
    1. **`std::move(up)`**
         将左值 `up` 转换成右值，这样容器就会调用 `push_back(T&&)`（即移动构造），而不是拷贝构造。
    
    2. **移动后**
    
    - `vec` 内部会通过 `unique_ptr` 的移动构造函数，把 `up` 持有的指针 **“夺走”**（transfer ownership）。
    - `up` 本身被置为 **空**（等价于 `up.get() == nullptr`）。

![image-20250621163705494](D:\MarkDown\Picture\image-20250621163705494.png)

**方法2: 直接以右值的方式创建up对象, 并作为参数存入容器vector中**

```c++
vector<unique_ptr<Point>> vec;	// 创建vector容器
vec.push_back( unique_ptr<Point>(new Point(3,4)) ); // 创建右值形式的unique指针
```





## shared_ptr

### 简介

共享所有权权的智能指针。

shared_ptr就是共享所有权的智能指针，可以进行复制或赋值，但复制或赋值时，并不是真正拷贝了被管理的对象，而只是将引用计数加1了。即==shared_ptr引入了引用计数==，其思想与COW技术类似，又称为是强引用的智能指针。

引用计数会记录有多少个指针指向同一个对象, 每多一个引用计数+1, 当这个引用计数降低为0时这个对象才会被自动析构

<img src="D:\MarkDown\Picture\image-20250703212935992.png" alt="image-20250703212935992" style="zoom:50%;" />



**特征1：共享所有权的智能指针**,    可以使用**引用计数**记录对象的个数。

**特征2：可以进行复制或者赋值**,    表明具备值语义。

**特征3：也可以作为容器的元素**,    作为容器元素的时候，即可以传递左值，也可以传递右值。（区别于unique_ptr只能传右值）

**特征4：也具备移动语义**,    表明也有移动构造函数与移动赋值函数。



### 两种初始化方式

```c++
/*-----------第一种-----------*/    
shared_ptr<int> sp1;
sp1 = make_shared<int>(77); // make_shared会动态创建一片内存, 然后让shared_ptr指向它, 任何情况下优先使用make_shared

/*-----------第二种-----------*/
shared_ptr<int> sp2(new int(88));
```

```c++
void test() {
    shared_ptr<int> sp(new int(111));
    cout << sp.get() << endl; // .get() 返回底层原生指针 T*
    cout << *sp << endl;
    cout << sp.use_count() << endl; // 返回引用计数, 表示当前有多少个 shared_ptr 管理同一对象sp（包含自己) 
    
    //进行一个拷贝操作
    cout << "进行拷贝操作" << endl;
    shared_ptr<int> sp2 = sp;
    cout << sp.use_count() << endl;
    cout << sp2.get() << endl; // 拷贝后原生指针不变, 还是指向同一片堆空间
    cout << *sp2 << endl;
    cout << sp2.use_count() << endl;
    
    //进行赋值操作
    cout << "进行赋值操作" << endl;
    shared_ptr<int> sp3(new int(222));
    cout << sp3.use_count() << endl;
    sp3 = sp2;
    cout << sp.use_count() << endl;
    cout << sp2.use_count() << endl;
    cout << sp3.use_count() << endl; // sp3被sp1赋值后, 引用计数变成了3
}
```

<img src="D:\MarkDown\C++基础\assets\image-20250703215200440.png" alt="image-20250703215200440" style="zoom:50%;" />



**无论是拷贝 移动构造 还是直接用右值赋值, share都可以作为容器的参数**

不同的方法引用计数不同

```c++
void test2() {
    //作为容器的元素
    shared_ptr<int> sp(new int(77)); // 在栈上创建一个 shared_ptr，管理堆上 new 出的 int(77) // 此时：sp.use_count() == 1
    vector<shared_ptr<int>> vec;     // 在栈上创建一个 vector，用来存放 shared_ptr<int>

    //此时执行的是一个深拷贝操作
    //无论是vec里面的sp还是外部的sp都可以正常使用
    vec.push_back(sp);  // 第一次 push_back：传入的是 sp（左值），调用的是拷贝构造  
                        // 拷贝构造会让 vec[0] (里面存的是一个sp)和 sp 共享同一个控制块和同一个 int(20) 
    cout << sp.use_count() << "__" << vec[0].use_count() << endl; // 现在：sp.use_count() == 2，vec[0].use_count() == 2



    vec.push_back(std::move(sp)); // 第二次 push_back：传入的是 std::move(sp)（右值），调用的是移动构造
                                  // 移动构造会把 sp 内部的原生指针赋值给 vec[1]，并把 sp 置为 empty（null）
    cout << sp.use_count() << "__" << vec[1].use_count() << endl;    // 注意：移动构造并不增加引用计数，所以引用计数仍然是 2，
                                                                     //      这两个拥有者分别是 vec[0] 和 vec[1]。
    //cout << *sp << endl;error // 此时sp指针已经被赋值给了vec[1] , 自己已经是nullptr



    vec.push_back(shared_ptr<int>(new int(42))); //  第三次 push_back：直接构造一个临时 shared_ptr<int> 管理新的 int(42)
                                                // 这个临时对象构造后被移动进 vec[2]，它是对 int(42) 的唯一拥有者
                                                // 此时：vec[2].use_count() == 1
    cout << vec[2].use_count() << endl;
                                                
    cout << *vec[0] << endl;
    cout << *vec[1] << endl;
    cout << *vec[2] << endl;
}
```

<img src="D:\MarkDown\C++基础\assets\image-20250703222332756.png" alt="image-20250703222332756" style="zoom:67%;" />

<img src="D:\MarkDown\C++基础\assets\image-20250703222356399.png" alt="image-20250703222356399" style="zoom: 67%;" />

### shared_ptr的循环引用

#### shared_ptr的循环引用

shared_ptr还存在一个问题 —— 循环引用问题。

> 我们建立一个Parent和Child类的一个结构
>
> ``` c++
> class Child;
> 
> class Parent
> {
> public:
> 	Parent()
> 	{ cout << "Parent()" << endl; }
> 	~Parent()
> 	{ cout << "~Parent()" << endl; }
> 	//只需要Child类型的指针，不需要类的完整定义
> 	shared_ptr<Child> _spChild;
> };
> 
> class Child
> {
> public:
> 	Child()
> 	{ cout << "child()" << endl; }
> 	~Child()
> 	{ cout << "~child()" << endl; }
> 	shared_ptr<Parent> _spParent;
> };
> ```
>
> 



> 由于shared_ptr的实现使用了引用计数，那么如果进行如下的创建
>
> 
>
> ``` c++
> shared_ptr<Parent> parentPtr(new Parent());
> shared_ptr<Child> childPtr(new Child());
> //获取到的引用计数都是1
> cout << "parentPtr.use_count():" << parentPtr.use_count() << endl;
> cout << "childPtr.use_count():" << childPtr.use_count() << endl;
> ```
>
> <img src="D:\MarkDown\C++基础\assets\undefined202403222027179.png" alt="image-20240322202756063" style="zoom: 50%;" />
>
> 
>
> 



> ``` c++
> parentPtr->_spChild = childPtr;
> childPtr->_spParent = parentPtr;
> //获取到的引用计数都是2
> cout << "parentPtr.use_count():" << parentPtr.use_count() << endl;
> cout << "childPtr.use_count():" << childPtr.use_count() << endl;
> ```

实际上形成了这样的结构

<img src="D:\MarkDown\C++基础\assets\image-20240508115748981.png" alt="image-20240508115748981" style="zoom:50%;" />

——程序结束时，发现Parent和child的析构函数都没有被调用

因为==childPtr和parentPtr会先后销毁，但是堆上的Parent对象和Child对象的引用计数都变成了1，而不会减到0，所以没有回收==

<img src="D:\MarkDown\C++基础\assets\image-20240508115701939.png" alt="image-20240508115701939" style="zoom:50%;" />





解决思路：

——希望某一个指针指向一片空间，能够指向，但是不会使引用计数加1，那么堆上的Parent对象和Child对象必然有一个的引用计数是1，栈对象再销毁的时候，就可以使引用计数减为0







解决思路：

——希望某一个指针指向一片空间，能够指向，但是不会使引用计数加1，那么堆上的Parent对象和Child对象必然有一个的引用计数是1，栈对象再销毁的时候，就可以使引用计数减为0

shared_ptr无法实现这一效果，所以引入了weak_ptr.



> weak_ptr是一个弱引用的智能指针，不会增加引用计数。
>
> shared_ptr是一个强引用的智能指针。
>
> 强引用，指向一定会增加引用计数，只要有一个引用存在，对象就不能释放；
>
> 弱引用并不增加对象的引用计数，但是它知道所托管的对象是否还存活。



——循环引用的解法，将Parent类或Child类中的任意一个shared_ptr换成weak_ptr类型的智能指针

比如：将Parent类中的shared_ptr类型指针换成weak_ptr

<img src="D:\MarkDown\C++基础\assets\image-20240508115831351.png" alt="image-20240508115831351" style="zoom:50%;" />



栈上的childPtr对象先销毁，会使堆上的Child对象的引用计数减1，因为这个Child对象的引用计数本来就是1，所以减为了0，回收这个Child对象，造成堆上的Parent对象的引用计数也减1

<img src="D:\MarkDown\C++基础\assets\image-20240508120233748.png" alt="image-20240508120233748" style="zoom:50%;" />



再当parentPtr销毁时，会再让堆上的Parent对象的引用计数减1，所以也能够回收。

<img src="D:\MarkDown\C++基础\assets\image-20240508120320252.png" alt="image-20240508120320252" style="zoom:50%;" />





## weak_ptr





# 删除器



## unique_ptr的删除器





## shared_ptr的删除器







# 误用问题

