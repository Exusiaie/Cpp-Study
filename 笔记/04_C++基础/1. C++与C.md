# 命名空间

什么是命名空间？其作用是什么？

命名空间是一个可以由程序员自定义的作用域, 作用是避免命名冲突, 此外可以规整代码,更好的版本控制和声明主权.

-------

全局命名空间VS匿名命名空间

全局命名空间的名称没有域限定, 也就是**全局变量命名的空间**

匿名命名空间是一个没有名字的命名空间，用于**封装不希望暴露给外部的实体**，**匿名命名空间的变量作用域限于定义所在文件内。**内部成员不会被其他的文件所访问

-------

命名空间的三种使用方法

```C++
#include <iostream>
using std::cout;
using std::endl;

// 这是一个全局变量, 与命名空间Ning中的实体同名
int value = 666;

// 命名空间Ning
namespace Ning
{
    int value = 777;
    const char *name = "Elden Lord";

    void func(){
        cout << "1_namespace 14:" << endl;
    }
}// end of namespace Ning

// 匿名命名空间
namespace{
    const char *str = "I am very mysterious...";
}// end of namespace


// 直接打印value会调用全局变量, 也就是全局命名空间
void test0(){
    cout << "test0: " << value << endl;
    cout << "访问全局命名空间: " << ::value << endl; 
}

// 要指定使用哪个命名空间内的实体, 有三种方式

// 1. 每次使用实体时都加上作用域限定符
// 准确但繁琐
void test1(){
    cout << "test1: " << Ning::value << endl;
    Ning::func();
}

// 2.使用using编译指令
// using会直接把指定的命名空间内所有的实体全部引用进来, 可能会造成冲突
void test2(){
   // using namespace Ning; 这两行代码存在ERROR, 因为using把Ning空间中所有的实体全部引用了进来 
   //cout << value << endl; 这就使得编译器看到了两个同名的value
}

// 3. 使用using声明机制, 需要什么就声明什么, 声明语句有作用域, 因此建议放在局部作用域内
void test3(){
   using Ning::value;   // 只把 Ning::value 带进来
   cout << "test3:" << value << endl;  // 这里访问的就是 Ning::value（0），不会跟 ::value 冲突
}

// 4. 访问匿名命名空间, ::前不需要带名字
void test4(){
    cout << "访问匿名命名空间" << str << endl;
    cout << ::str << endl;
}


int main()
{
    test0();
    test1();
    test2();
    test3();
    test4();

    return 0;
}

```

<img src="D:\MarkDown\Picture\image-20250604152237834.png" alt="image-20250604152237834" style="zoom: 67%;" />





# const修饰符(important)

以int指针为例，用const修饰有三种形式：

`const int * p`      `int const * p1`     ` int * const p2`



| 英文名           | 写法                            | 解释                                                         | 记忆                                                         |
| ---------------- | ------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| pointer to const | const int *p  或者 int const *p | 表示指针p指向的值是一个常量值, 不可以根据指针修改它所指向的值, 但是可以更改指针指向的地址 | [数据类型] *指针名 数据类型中带const, 表示指针指向的内存空间是const |
| const pointer    | int *const p                    | 表示指针p是一个被const修饰了的常量指针, 里面保存的地址值是常量, 不可更改指针指向的地址, 但是可以根据指针修改它所指向的值 | [数据类型] *指针名 指针名中带const, 表示指针自己是const      |

 

```C++
#include <iostream>
using std::cout;
using std::endl;


int main()
{
    int value1 = 111;
    int value2 = 222;
    
    // 1. point to const
    const int *p1 = &value1; // [数据类型] *指针名 数据类型中带const, 表示指针指向的内存空间是const
    int const *p2 = &value1;

    // 2. const point
    int *const p3 = &value2; // [数据类型] *指针名 指针名中带const, 表示指针自己是const


    //*p1 = 999; // ERROR point to const 不能更改指向的内存空间的值, 但是可以更改指向
    p1 = p3;
    p2 = p3;
    cout << "指向从value1更改为value2: " << *p1 << endl;

    //p2 = p1;   // ERROR const point    不能更改指向, 但是可以更改指向的内存空间的值
    *p3 = 999;
    cout << "p3指向的内存空间从222修改成了999: " << *p3 << endl;


 return 0;
}

```

<img src="D:\MarkDown\Picture\image-20250604154033230.png" alt="image-20250604154033230" style="zoom: 67%;" />

--------

`const`关键字与宏定义的区别是什么？

一: 作用时机不同. 宏定义发生的时机是在预处理阶段, 发生bug后不能立即发现, 只能到运行阶段才能发现;  const关键字发生的时期是在编译阶段, 发生bug后立即发现

二: 类型和安全检查不同: 宏定义没有类型, 在预处理时期它所做的只是简单的文本替换;  const关键字描述的对象有具体的数据类型, 在编译时会做正常的类型检查





# 引用



```C++
#include <iostream>

using std::cout;
using std::endl;

// 指针传递：函数参数是一个指向 int 的指针
void funcPointer(int* p) {
    cout << "【funcPointer 内部】\n";
    // &p：形参“指针变量 p”在栈上的地址
    cout << "  地址 &p   = " << &p << " // p 本身是一个局部指针变量\n";
    // p：形参 p 的值，也就是实参传入的指针值（指向 main 中 x 的地址）
    cout << "  值 p = " << p << " // 指向 main 中 x 的地址\n";
    // *p：取出 p 指向的内存中的数据，应该就是 x 的值
    cout << "  *p = " << *p << " // 通过指针访问 x 的内容\n\n";
}

// 引用传递：函数参数是一个对 int 的引用
void funcReference(int& r) {
    cout << "【funcReference 内部】\n";
    // &r：形参“引用 r”在这一层看，相当于直接映射到实参 x 的地址
    cout << "  地址 &r = " << &r << " // 引用直接映射 main 中 x 的地址, 这使得它的地址与实参地址一致\n";
    // r：使用引用时，直接就是实参 x 的值
    cout << "  值 r = " << r << " // 与 main 中 x 的值相同\n\n";
}

// 方式一：正确地返回一个传入参数的引用
int& funcReturn(int& ref) {
    cout << "[funcReturnReference 内部]\n";
    cout << "  地址 &ref = " << &ref << " // ref 只是 main 中变量y的别名\n";
    cout << "  值 ref = " << ref << " //与 main 中变量的值相同\n\n";
    ref += 10;
    return ref;  // 返回对外部变量的引用
}

// 方式二：错误示范——返回局部变量的引用（切勿在实际代码中这样做）
// int& badReturnLocal() {
//     int temp = 999;
//     std::cout << "【badReturnLocal 内部】\n";
//     std::cout << "  地址 &temp = " << &temp
//               << "    （temp 是局部变量，函数返回后就会被销毁）\n";
//     std::cout << "  值 temp   = " << temp << "\n\n";
//     return temp; // ERROR: 返回局部变量的引用会导致悬空引用
// }


int main() {
    int x = 42;
    cout << "------ 主函数 main 中 ------\n";
    // &x：打印实参 x 在内存中的地址
    cout << "  地址 &x  = " << &x << " // main 中的变量 x 的地址 \n";
    cout << "  值 x = " << x << " // main 中 x 的值 \n\n";

    // —— 第一：用指针传递 x 的地址给 funcPointer —— 
    cout << "---- 调用 funcPointer(&x) ----\n";
    funcPointer(&x);

    // —— 第二：用引用传递 x 给 funcReference —— 
    cout << "---- 调用 funcReference(x) ----\n";
    funcReference(x);

    cout << "_________________" << endl;

    int y = 777;
        // —— 3. 函数返回引用：正确示例（返回 main 中 y 的引用） —— 
    cout << "---- 调用 funcReturn(y) 并接受返回引用 ----\n";
    int& refY = funcReturn(y);
    cout << "在funcReturn 中修改了ref的值, 相当于直接修改了y的值 \n";
    cout << "  在 main 中，refY 的地址 &refY = " << &refY << " // 与 &y 相同，应等于 " << &y << "\n";
    cout << "  在 main 中，refY 的值 r = " << refY << " // 与 y 的值相同，应等于 " << y << "\n\n";

    // 修改 refY（也会改变 y）
    std::cout << "---- 通过 refY 修改 y 的值 ----\n";
    refY = 200;
    cout << "  修改后，y = " << y << " // 说明 refY 直接操作的是 y\n";
    cout << "  修改后，refY = " << refY << "\n\n";

    cout << "结论, y ref refY 三者都是同一个地址上的数据的不同名字, 它们的地址值都是一样的" << endl;
    cout << &y << "   "<< &refY << endl;    

    return 0;
}


```

![image-20250604165809846](D:\MarkDown\Picture\image-20250604165809846.png)

-----------------------

引用与指针的联系和区别是什么？

联系:

1. 引用和指针都有地址的概念，都是用来间接访问变量。指针指向一块内存，它的内容是所指内存的地址；引用是某块内存的别名；

2. 引用的底层还是指针来完成，可以把引用视为一个受限制的指针。

区别: 
1. 引用是对一个对象取别名, 而指针是一个实体
2. 引用一经绑定, 就不可再更改, 而指针还可以更改指向的值
3. 引用在使用时无需解引用, 但是指针在使用时要用*进行解引用操作
4. sizeof引用会得到整个引用对象的大小; 但是sizeof指针只会得到指针类型自己的大小
5. 对于数组, 引用类型自增运算会跳过整个数组, 指针类型自增运算会让数组进到下一个元素

------------------------

永远注意:  <font color=red>函数不要返回局部变量的引用or指针</font>, 它们返回的都是这个局部变量的地址, 函数销毁后这个地址也将销毁

------------------------

总结:
作为函数的参数，如果不希望改变实参的数值，可以如何传递
	值传递
	指针传递
		需要const限定
	引用传递
		需要const限定
		适用于参数比较大，如果复制一份会比较占用开销
作为函数的参数，希望改变实参的数值，可以如何传递
	指针传递
	引用传递







# 内存布局

64位系统，理论空间达到16EB（2^64）,但是受硬件限制，并不会达到这么多；

以32位系统为例，一个进程在执行时，能够访问的空间是**虚拟地址空间**。理论上为2^32，即4G，有1G左右的空间是内核态，剩下的3G左右的空间是用户态。从高地址到低地址可以分为五个区域：



------

🧠 1. 栈区（Stack）

- 函数调用时自动分配的变量和参数都放在这
- 进入函数时压栈，退出函数时自动销毁
- **快速但大小有限**（几 MB）

✅ 示例：

```c++
void func() {
    int a = 10;  // a 在栈上
}
```

------

 🧠 2. 堆区（Heap）

- 手动分配的内存，用 `new` 或 `malloc`
- 程序员自己负责释放（用 `delete` 或 `free`）
- **灵活但可能内存泄漏**

✅ 示例：

```c++
int* p = new int[10];  // 在堆上分配10个int
delete[] p;            // 释放堆内存
```

------

📦 3. 静态区 / 全局区（Data Segment）

- 存放全局变量、静态变量。（无论函数里还是外面）
- 程序整个运行期间都存在
- **编译时就确定大小**

✅ 示例：

```c++
int globalVar = 5;     // 全局变量 → 静态区
void func() {
    static int count = 0;  // 静态局部变量 → 静态区
}
```

------

 📚 4. 只读常量区（ROData）

- 放字符串字面值（如 `"hello"`）和 `const` 修饰的全局常量
- **不可修改，修改会导致程序崩溃或错误**

✅ 示例：

```c++
const int x = 100;        // 在常量区（如果是全局 const）
const char* s = "Hi";     // "Hi" 是只读字符串 → 常量区
```

------

🧾 5. 代码区（Text）

- 存放程序的 **机器指令（函数代码）**
- **只读、共享**（多个程序用相同库时可共用）

![image-20250604173040562](D:\MarkDown\Picture\image-20250604173040562.png)



-------------

`new/delete`与`malloc/free`的区别是什么

类型和返回值: malloc/free的返回值是一个void*, 必须显示的转换成需要的数据类型; new/delete 返回了具体类型的指针

内存安全: malloc/free在内存不够分配时会返回NULL需要程序员自己处理; new/delete有专门的内存溢出检测工具

参数不同: malloc/free需要指定内存空间的大小并且初始化; new/delete直接返回具体的类型指针

成对出现: malloc对应free, new对应delete



#  浅拷贝和深拷贝



```c++
class Location4 {
public:
    Location4(int x, int y, const char *name)
    : _x(x), _y(y), _name(new char[strlen(name)+1])  // +1 for '\0'
    {
        strcpy(_name, name);
    }

    ~Location4() {
        delete[] _name;
    }

private:
    int _x, _y;
    char* _name;
};
```

问题: 在第四行:

```c++
_name(new char[strlen(name)+1]
```

为什么不能直接写成：

```c++
_name = name;
```

而非要：

```c++
_name = new char[strlen(name)]();
strcpy(_name, name);
```

------

 ** 理解背后的原理：浅拷贝 vs 深拷贝**

  👉方法一：直接赋值（浅拷贝）

```c++
_name = name;
```

 只是把**指针的地址**复制过来，**两个对象共用同一块内存**。

- 优点：快
- 缺点：危险！两个对象可能互相影响，特别是当其中一个析构时会导致**悬空指针/重复释放**。

------

  👉方法二：使用 `new` 分配空间（深拷贝）

```c++
_name = new char[strlen(name)]();
strcpy(_name, name);
```

 为对象的 `_name` 成员分配**独立的内存空间**，并复制内容。

- 优点：安全。每个对象维护自己的内存。
- 缺点：稍慢，要手动管理内存（需要在析构函数中 `delete[] _name`）

  正确做法：如果类中包含**指针成员**，你应当：

1. **构造函数里深拷贝**
2. **自定义析构函数释放内存**
3. （可选）自定义拷贝构造函数和赋值运算符

------------------------

## new关键字

凡是写出类似

```c++
T* p = new T(/*…*/);
```

这样的**new表达式**（new‐expression），它都会从 堆 中拿内存，给对象分配空间，然后调用构造函数来初始化该对象。

> **注意区分**
>
> - **自动存储区**（automatic storage）：也就是“栈”（stack），函数里普通的局部变量就分配在这里；
> - **静态存储区**（static storage）：程序全局或者用 `static`、`extern` 修饰的变量；
> - **自由存储区**（free store）：用 `new`/`delete` 管理的那块，一般就叫“堆”。









# 函数重载

<font color=red>**在同一作用域内，可以有一组具有相同函数名，不同参数列表的函数，这组函数被称为重载函数。**</font>重载函数通常用来命名一组功能相似的函数，这样做减少了函数名的数量，对于程序的可读性有很大的好处。

```C++
#include <iostream>
using std::cout;
using std::endl;

// 重载版本 1：两个 int 相加
int add(int a, int b) {
    return a + b;
}

// 重载版本 2：两个 double 相加
double add(double a, double b) {
    return a + b;
}

// 重载版本 3：三个 int 相加
int add(int a, int b, int c) {
    return a + b + c;
}

int main() {
    int x = 10, y = 20, z = 30;
    double u = 1.5, v = 2.7;

    cout << "add(x, y) = " << add(x, y) << endl; 

    cout << "add(u, v) = " << add(u, v) << endl; 

    cout << "add(x, y, z) = " << add(x, y, z) << endl; 

    return 0;
}

```

<img src="D:\MarkDown\Picture\image-20250604201150170.png" alt="image-20250604201150170" style="zoom:67%;" />

实现原理：  名字改编(name mangling)——当函数名称相同时 ，会根据参数的类型、顺序、个数进行改编

