# 一. 面向过程和面向对象

1. **面向对象：实体中心论**

    世界由**离散的、具有内在属性的实体（对象）**构成。这些实体通过**关系（交互）**构成复杂系统。实体是属性的载体，是独立存在的“第一本体”。

    编程: 对象（如 `Car`、`User`）封装了状态（属性）和行为（方法），成为系统中的基本存在单位。对象间通过消息传递（方法调用）协作。

2. **面向过程：过程中心论**

    世界由**动态的过程（Procedures）和数据流**构成。实体是过程演化的临时产物。存在是永恒的变化；实在的本质是“生成”而非“存在”。

    程序是**函数/过程的序列**（如 `calculate()`、`render()`），数据作为过程的输入与输出流动。状态通常由共享数据结构（全局变量）承载。

过程论和对象论不是一种你死我活的绝对对立，而是一种辩证统一的对立，两者相互渗透、在一定情况下可以相互转化，是一种“你中有我、我中有你”的对立。如果将对象论中的所有交互提取出来而撇开对象，就变成了过程论，而如果对过程论中的数据和逻辑分类封装并建立交互关系，就变成了对象论。

过程论相对确定，有利于明晰演进的方向，但当事物过于庞大繁杂，将很难理清思路。因为过程繁多、过程中又有子过程，容易将整个世界看成一个纷繁交错的过程网，让人无法看清。对象论相对不确定，但是因为以对象为基本元素，即使很庞大的事物，也可以很好地分离关注，在研究一个对象的交互时，只需要关系与其相关的少数几个对象，不用总是关注整个流程和世界，**对象论更有助于分析规模较大的事物**。但是，对象论也有困难。例如，如何划分对象才合理？对于同一个驱动力，为什么不同情况下参与对象和交互流程不一样？如何确定？其实，这些困难也正是面向对象技术中的困难。





# 二. 构造函数和析构函数

```C++
#include <iostream>
#include <string.h>

using std::cout;
using std::endl;

// 什么都没有的类定义, 会默认创建拷贝函数, 构造函数, 析构函数, 
class Location1{
public:
    void PrintLocation(const char *name){
        cout << "location " << name << " is: (" << _x << "," << _y << ")" << endl;
    }  
    int _x = 0;
    int _y = 1;
};


// 类内部声明, 外部定义, 这个外部可以是另个一专门用来定义的文件, 但不能是main函数内
class Location2{
public:
    void PrintLocation(const char *name);  
    int _x = 0;
    int _y = 1;
};
void Location2::PrintLocation(const char *name){
    cout << "location " << name << " is: (" << _x << "," << _y << ")" << endl;
}


// 使用构造函数的类定义, 构造函数带有参数和初始化列表, 这使得它拥有更大的自由度
// 使用含参构造函数, 要在创建对象时传参
class Location3{
public:
    Location3(int x, int y)
    :_x(x), _y(y) // 初始化列表使用类似函数的( )赋初值
    {
    
    }

    void PrintLocation(const char *name){
        cout << "location " << name << " is: (" << _x << "," << _y << ")" << endl;
    }  
    int _x;
    int _y;
};


// 使用含有指针数据成员的类, 意味着创建该类对象时必须要进行指针成员的初始化
class Location4{
public:
    Location4(int x, int y, const char *name)
    : _x(x), _y(y) 
    ,_name(new char[strlen(name)+1]()) // new char[N] 本来会分配一个长度为 N 的 char 数组，但此时数组中的内容是“未定义”的（即垃圾值）。C++ 中，如果你写成 new char[N]()，那么编译器会对这块 [N] 大小的数组做值初始化，把每个元素都“清零”——对 char 数组来说，最终等同于把所有字节设为 '\0'。() 是专门告诉编译器“这个数组内容要初始化为 0” ——> new T[...]()。
    {
        strcpy(_name, name);
    }

    void PrintLocation(){
        cout << "location " << _name << " is: (" << _x << "," << _y << ")" << endl;
    }

    int _x;
    int _y;
    char *_name;
};

// 上面的类在初始化指针成员时new了一个堆空间, 但是没有Free, 这会造成内存泄漏
// 因此引入了析构函数
class Location5{
public:
    Location5(int x, int y, const char *name)
    : _x(x), _y(y) ,_name(new char[strlen(name)+1]())
    {
        strcpy(_name, name);
    }
    
    ~Location5(){
        delete [] _name; // [] C++ 中 new[]/delete[] 配对使用, 告诉编译器这是一个数组, 每一个成员都要调用析构函数
    }

    void PrintLocation(){
        cout << "location " << _name << " is: (" << _x << "," << _y << ")" << endl;
    }

private:
    int _x;
    int _y;
    char *_name;
};

int main()
{
    Location1 l1;
    Location2 l2;
    Location3 l3(4, 2); // 只能在此时传参, 先创建对象在传参会造成未定义行为
    const char *name = "Laterano";
    Location4 l4(4, 3, name);
    Location5 l5(4, 4, name);

    l1.PrintLocation(name);
    l2.PrintLocation(name);
    l3.PrintLocation(name);
    l4.PrintLocation();
    l5.PrintLocation();

    return 0;
}
// 两个比较奇怪的语法

```

<img src="D:\MarkDown\Picture\image-20250604194804410.png" alt="image-20250604194804410" style="zoom:67%;" />

------

作用:

1. 构造函数就是用来初始化数据成员的, 没有返回值, 即使是void也不能有; 函数名与类名相同, 再加上函数参数列表
2. 析构函数提供了一个数据清理的入口, 当对象被销毁时, 会自动调用析构函数



-------
注意: 
1. 当类中没有显式定义构造函数时 ，编译器会自动生成一个默认  (无参)  构造函数 ，但并不会初始化数据成员
2. 析构函数默认情况下 ，系统也会自动提供一个, 析构函数不能自己手动调用, 这会造成double free
3. 数据成员的初始化并不取决于其在初始化列表中的顺序，而是取决于声明时的顺序（要求与声明顺序一致）, 比如声明时是先声明x后声明y，那么在初始化列表中也保持相同的顺序
4. 构造函数可以定义多个形成重载, 析构函数无法做到



-------------------------

## 2. 1 默认参数

1. 在参数列表中，一旦你给某个参数指定了默认值，那么它后面所有的参数也都必须有默认值，才能保证调用时参数省略的匹配是不歧义的, 因为C++ 按“从左到右、按位置”来匹配实参和形参. 

```C++
// 合法：只有最后一个参数有默认值
void func(int a, int b = 2);
// 合法：最后两个参数都有默认值
void func(int a = 1, int b = 2);
// 不合法：第一个参数有默认值，但第二个没有
void func(int a = 1, int b);   // ❌ 编译报错！

```

2. 在类内部声明时写默认值，类外定义时**不要重复写默认值**。



---------------------------------

## 2.2 初始化列表中的两种初始化方式

在 C++ 的成员初始化列表里，形如

```C++
_brand(new char[strlen(other._brand) + 1]())
```

和

```C++
_price(price)
```

中的括号其实是两种不同的初始化方式：

 1. _price(price) —— 直接初始化（direct initialization）

```C++
_price(price)
```

这跟你写普通函数调用很像：把外面传进来的 `price` 这个值“直接”用来初始化成员变量 `_price`。

等价于：

```C++
_price = price;  // 在构造体内部，相当于这样赋值
```

但它发生在对象已经开始构造、进入函数体之前，是最快也最安全的方式。

 2. `_brand(new char[…]())` —— 值初始化（value‐initialization）

```c++
_brand(new char[strlen(other._brand) + 1]())
```

这里有两步：

1. **`new char[N]`** ：给你一块“未初始化”的原始内存，里面的字节是垃圾。
2. **尾随的 `()`** ：告诉编译器“对这块内存做值初始化”，也就是把它**全部填成 0**。

- 对于基本内置类型（`char`、`int`、`float` 等），值初始化（`T()`）会让它们变成零（`0`、`'\0'`、`0.0f`…).
- 对于类类型（有构造函数的对象），值初始化会调用它们的**默认构造函数**。

如果你写成

```C++
_brand(new char[N]);
```

那 `new char[N]` 分配的内存就不会自动置零，里面可能是任意未定义的字节——这时候再 `strcpy` 可能会踩到边界，所以加上 `()` 就能确保“全空”安全地当做目标缓冲区。

一般情况下使用第二种初始化方式, 还要在函数体内加上

`strcpy(brand, other.brand);`



----------

自己主动调用析构函数容易导致double free



# 三. 拷贝构造函数

拷贝构造函数的形式固定：**类名(const 类名 & other)  **

1. 该函数是一个构造函数  —— 拷贝构造也是构造！
2. 该函数用一个已经存在的同类型的对象，来初始化新对象，即对对象本身进行复制      


```C++
#include <string.h>
#include <iostream>
using std::cout;
using std::endl;


class Computer1{
public:
    Computer1(const char * brand, float price)
    :_brand(new char[strlen(brand) + 1]())
    ,_price(price)
    {
        strcpy(_brand ,brand);
        cout << "调用构造函数" << endl;
    }
    //编译器生成的拷贝构造函数如下
    Computer1(const Computer1 & other)
    :_brand(other._brand)//  _brand = other._brand
    ,_price(other._price)
    {
        cout << "Computer(const Computer &)" << endl;
    }

    ~Computer1(){
        if(_brand != 0){
        cout << "调用析构函数" << endl;
            delete [] _brand;
            _brand = nullptr;
        }
    }

    void print(){
        cout << "_brand=" << _brand << ",_price=" << _price << endl;
    }

private:
    char * _brand;
    float _price;
};




class Computer2{
public:
    Computer2(const char * brand, float price)
    :_brand(new char[strlen(brand) + 1]())
    ,_price(price)
    {
        strcpy(_brand ,brand);
        cout << "调用构造函数" << endl;
    }
// 自定义的拷贝函数
    Computer2(const Computer2 & other)
    :_brand(new char[strlen(other._brand) + 1]())
    ,_price(9999)  // 可以在自定义的拷贝构造函数中修改内容
    {
        strcpy(_brand, other._brand);
        cout << "调用拷贝构造函数" << endl;
    }

    ~Computer2(){
        if(_brand != 0){
        cout << "调用析构函数" << endl;
            delete [] _brand;
            _brand = nullptr;
        }
    }

    void print(){
        cout << "_brand=" << _brand << ",_price=" << _price << endl;
    }

private:
    char *_brand;
    float _price;
};

// 当使用编译器生成的默认拷贝构造时，Computer1 c2 = c1; 会发生一次浅拷贝，也就是：
// c1._brand 和 c2._brand 都指向同一块堆内存(同一个char[])
// 程序结束时，c1 的析构会先执行 delete [] _brand;，把那块内存释放
// 随后 c2 的析构也会执行 delete [] _brand;，试图再次释放已被释放的内存 → 导致 double free
void test1(){
    Computer1 c1("apple", 7600);
    c1.print();
    //下面这行代码会调用拷贝构造函数
    Computer1 c2 = c1;
    c2.print();
}

// 因为自定义拷贝构造函数中使用了深拷贝, 这使得两个类中的指针成员不会指向同一片地址空间, 也就没有了double free
void test2(){
    Computer2 c1("Apple", 12000);
    c1.print();
    Computer2 c2 = c1;
    c2.print();
}

int main()
{
    test2();
    return 0;
}


```

<img src="D:\MarkDown\Picture\image-20250604221204821.png" alt="image-20250604221204821" style="zoom:67%;" />

----------------

## tips

3.1 拷贝构造函数调用的时机是什么时候?

> 常见的拷贝操作:
>
> 1. 一般的赋值操作 : 
>
>  ```C++
>  int a = 777; 
>  b = a;
>  ```
>
> 2. 函数的参数传递:
>
>     ```c++
>     void func(int a){
>     } 
>     void main(){
>         int a = 777;
>         func(a); //这里调用 func(a) 时，a 的值（777）会拷贝到函数 func 的形参 a（形式上一样，但它是个新的局部变量）里。
>     }
>     ```
>
> 3. 函数的返回值:
>     ```c++
>     int func(int a){
>         return a;
>     } 
>     void main(){
>         int a = 777;
>         int b = func(a); // 函数返回时，形参 a 的值会复制到调用点左边的接收变量（这里是 b）。
>     }
>     ```
>     
>     因此我们可以退出, 拷贝构造函数的三个调用时机也是这三种

1. 当使用一个已经存在的对象初始化另一个同类型的新对象时；

2. 当函数参数（实参和形参的类型都是对象），形参与实参结合时（实参初始化形参）；

    —— 为了避免这次不必要的拷贝，可以使用引用作为参数

3. 当函数的返回值是对象，执行return语句时（编译器有优化）。——为了避免这次多余的拷贝，可以使用引用作为返回值，但一定要确保返回值的生命周期大于函数的生命周期

    

--------------------

3.2 全局对象、局部对象、静态对象、堆对象创建和销毁时机不同:
全局对象：程序开始运行便会创建出全局对象; 程序即将结束之前销毁
局部对象：调用了创建对象的语句,出了局部作用域便会销毁
静态对象：如果存放在全局位置，那么和全局对象一致，如果存放在局部作用域内，那么执行到这行代码时，创建该对象;程序即将结束时才会销毁静态对象
堆对象：new的时候会创建该对象，delete的时候会销毁, 是由程序员自主控制的

-----------

3.3 浅拷贝和深拷贝

浅拷贝仅复制对象的成员值（包括指针的地址），导致多个对象共享同一块资源；

深拷贝不仅复制成员值，还为指针所指向的资源分配独立内存，确保各对象拥有自己的副本。

-----------------------

3.4引用&能不能去 | const能不能去

1. 去掉&引用:

**拷贝构造函数的参数此时变成了传值（不是引用）**，意味着在调用拷贝构造函数时，要先拷贝 `other` 对象；

**但“拷贝”这个行为本身就需要调用拷贝构造函数**；

所以会再调用一次拷贝构造函数来传入 `other`，于是进入了无限递归的死循环（编译器尝试构造 `other` → 又要构造 `other` → …）。

 最终会导致栈溢出

2. 去掉const:

若去掉会导致拷贝构造函数不能初始化const对象和右值

除非有移动构造函数









# 四. 赋值运算符函数

赋值运算符函数定义了**如何将一个对象赋值给另一个已存在的对象**。

在使用 `obj1 = obj2;` 时，就会自动调用这个函数。如果类中没有显式定义赋值运算符函数时，编译器会自动提供一个赋值运算符函数, 这自然会造成浅拷贝的问题

`operator=` 是 **C++中重载赋值运算符的固定写法**

格式为: **类名& operator=(const 类名 & other) { }**

-------------------

## 4.1 This指针

`this` 指针是 C++ 中 **类的非静态成员函数内部**自带的一个特殊指针，指向**调用该成员函数的当前对象**。`this` 的类型是 `ClassName*`（类的指针类型）；所以可以通过 `*this` 来得到这个对象本身（以值的形式）, 也可以通过 `this->成员变量` 来访问对象的成员

 🔧 一句话解释：

 在成员函数内部，`this` 就代表当前对象的地址，`*this` 就是当前对象本身。

-----------

```C++
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <cstring>
#include <string>
using namespace std;

class Person {
public:
	// 1. 构造函数, 调用时机是一般创建对象的时候
	Person(const char* name, int age = 0) // 给出了默认参数
		:_name(new char[strlen(name) + 1]()), // 不能这样写name(new char(strlen(name) + 1))
		_age(age)		// 给数据成员赋初值
	{
		strcpy(_name, name);
		cout << this << "调用构造函数" << endl;
	}

	// 2. 拷贝构造函数, 调用时机有三种...最常见的是用已经存在的other对象给新创建的对象赋值
	Person(const Person& other) // 一般情况下这里的参数是创建时给出的, 但这是拷贝构造, 所以参数就变成了已有的那个对象 
								// other指的是另一个对象, 一般是已有的那个对象(拷贝构造的Source)
		:_name(new char[strlen(other._name) + 1]()), // 使用堆空间申请一个自己的内存,避免浅拷贝问题. 
		_age(other._age) // 用已有对象赋值自己的_age
	{
		strcpy(_name, other._name); // 用已有对象赋值自己的_name
		cout << this << "调用拷贝构造函数" << endl;
	}

	// 3. 赋值运算符函数, 调用时机只有一种, 对象已经存在, 用同样已经存在的other对象给它重新赋值
	/* 赋值运算符函数书写的四步:
		1. 考虑自赋值问题
		2. 清理左操作数的数据成员原本申请的堆空间
		3. 赋值(考虑深拷贝的问题)
		4. 返回*this（本对象）
	*/
	Person &operator = (const Person& other) 
	{
		if (this != &other) { // if(this == &other) 就表示对象和other对象, 他两是同一个对象, 属于自赋值, 需要规避掉, 直接返回指向本对象的指针
			delete[] _name; // 清理左操作数原来的堆空间
			_name = new char[strlen(other._name) + 1](); // 申请新的堆空间
			strcpy(_name, other._name); // 接收右操作数传值
			_age = other._age;
		}
		cout << this << "调用赋值运算符函数" << endl;
		return *this;
	}

	void PrintInfo() {
		cout << "name:" << _name << endl;
		cout << "age:" << _age << endl;
		cout << this << ":-----------" << endl;
	}

	// 4. 析构函数, 调用时机是在对象被销毁时自动调用
	~Person() {
		if (_name != nullptr) {
			delete[] _name;
			_name = nullptr;
		}
		cout << this << "调用析构函数" << endl;
	}

private:
	char* _name;
	int _age;
};

void test1() {
	Person p1("小明", 60);
	Person p2("小洙", 70);
	p1.PrintInfo();
	p2.PrintInfo();
}


int main() {
	test1();
	return 0;
}

```

1. this指针

<img src="D:\MarkDown\Picture\image-20250607150413669.png" alt="image-20250607150413669" style="zoom:67%;" />

2.  为什么不能写`name(new char(strlen(name) + 1))`而是`_name(new char[strlen(name) + 1]())`

    这两种写法在**分配对象的数量**和**初始化方式**上有本质区别：

    ```c++
    // 写法 A
    _name(new char(strlen(name) + 1));
    
    // 写法 B
    _name(new char[strlen(name) + 1]());
    ```

    1. 分配数量

    - **写法 A：** `new char(sz)`
         这并不是在分配一个 “长度为 sz 的字符数组”。它是调用单个对象的 **直接初始化** 形式，等价于

        ```c++
        cpp复制编辑char* p = new char;      // 分配一个 char
        *p = char(sz);           // 用 sz 转成 char 的值来初始化它
        ```

        – **结果**：只会在堆上开辟**1 字节**的空间，不会分配 `sz` 字节。然后把 `sz`（经转换后的 `char` 值）存进去。

    - **写法 B：** `new char[sz]()`
         这是数组形式的 `new[]`，会在堆上分配 `sz` 个 `char`，也就是一个字节数组，正好能容纳 `strlen(name)+1` 个字符（包括末尾的 `'\0'`）。

    2. 初始化行为

    - **写法 A**（单个对象直接初始化）：
        - 使用的是 **直接初始化**，对于内建类型 `char`，它会把传进去的值（这里是 `sz`）转换并存到那唯一的一个 `char` 里。
    - **写法 B**（数组加上尾部 `()`）：
        - 末尾的 `()` 表示 **值初始化**（value-initialize）整个数组。对于内建类型，值初始化等价于将每个元素 **零初始化**。
        - 如果你写成 `new char[sz]`（没有尾随 `()`）的话，数组元素将 **保持未初始化**（内存中的旧数据）。



## tips

4.2 四步骤

自赋值, 释放左操作数, 深拷贝, 返回*this 

-----------

4.3 细节问题

1. 参数引用$和返回结果引用&能不能去: 

& 如果去掉会多拷贝一次, 分别符合拷贝发生时机的"传参时拷贝"和"函数返回时拷贝"

2. const能不能去:

不能赋值const和

3. 返回结果类型能不能改变:

如果返回结果改变, 执行连等的时候会发生类型不匹配的现象

```c++
Point &operator = (const Point &rhs); // 若改成void operator=(const Point &rhs)
Point pt2 = pt1 = pt; // 此时(Point) = (void) = (void) , 类型不匹配
```





# 五. 拷贝构造函数和赋值运算符函数的区别

| 特性             | 拷贝构造函数                                       | 赋值运算符函数                                          |
| ---------------- | :------------------------------------------------- | ------------------------------------------------------- |
| **函数格式**     | `ClassName(const ClassName& other)`                | `ClassName& operator=(const ClassName& other)`          |
| **调用时机**     | 对象**创建**时用已有对象初始化                     | 对象已存在时给其**重新赋值**                            |
| **返回值**       | 无（构造函数不返回）                               | 必须返回 `*this` 的引用，支持链式赋值                   |
| **自我赋值检查** | 通常不需要（对象刚创建，不会自我拷贝）             | 通常要加 `if (this == &other) return *this;` 以进行自我 |
| **默认生成**     | 如果没自定义，编译器会生成一个按成员逐一拷贝的版本 | 如果没自定义，编译器也会生成一个默认版本                |
| **使用场景示例** | `ClassName a = b;` `ClassName c(b);`               | `a = b;`                                                |









# 六. C++中的左值和右值



| 术语 | 英文   | 简单记忆                           |
| ---- | ------ | ---------------------------------- |
| 左值 | lvalue | 可以取地址、可持久存在的对象       |
| 右值 | rvalue | 临时的、不能取地址的值或表达式结果 |

---------

左值（lvalue）：

- 可以出现在赋值语句的 **左边或右边**
- 有 **名字**，可以 **取地址**
- 生命周期相对较长

**例子：**

```c++
cpp复制编辑int x = 5;   // x 是左值
x = 10;      // x 出现在左边，赋值没问题
int *p = &x; // 出现在右边, 可以对 x 取地址
```


右值（rvalue）：

- **只能**出现在赋值语句的 **右边**
- **不能**取地址（或者说没意义）
- 是**临时值、常量或表达式结果**

**例子：**

```C++
cpp复制编辑int y = 10;     // 10 是右值
int a = x + y;  // x+y 是右值（表达式结果）
int *p = &(x + y); //  错误，x+y 是右值，不能取地址
```







# 七. 三合成原则

<span style=color:red;background:yellow>**三合成原则**</span>很容易在面试时被问到：

**拷贝构造函数、赋值运算符函数、析构函数，如果需要手动定义其中的一个，那么另外两个也需要手动定义。**





# 八. 特殊的成员函数



## 8.1 static成员函数

**静态成员函数（static member function）**

没有隐含的`this`指针, 无法访问非静态成员, 属于类本身, 被类的所有对象共享

可以使用类名+作用域限定符的形式进行调用

```cpp
class MyClass {
public:
    static int s_count;

    static void printCount() {
        // 可以访问静态成员
        std::cout << "Count = " << s_count << std::endl;
    }
    
    void foo() {
        // 非静态成员函数也可调用静态成员函数
        printCount();
    }
};

// 调用方式：
MyClass::printCount();       // 推荐：通过类名
obj.printCount();            // 也可通过对象，但不推荐
```

1. **典型用途**

    - 提供与类全局状态相关的功能，如工厂方法（返回新对象）、统计查询方法等。
    - 不依赖任何对象状态的工具函数。

2. **与普通成员函数的区别**

    | 特性     | 普通成员函数       | 静态成员函数       |
    | -------- | ------------------ | ------------------ |
    | 隐藏参数 | 隐含 `this` 指针   | 无 `this`          |
    | 访问权限 | 可访问所有实例成员 | 只能访问静态成员   |
    | 调用方式 | 需通过对象或指针   | 可直接通过类名调用 |
    | 绑定时机 | 动态或静态绑定     | 静态绑定           |

------

**总结**

- **静态数据成员** 用于存储跨所有对象共享的状态，只需定义一次；
- **静态成员函数** 用于操作或访问这些共享状态，且不依赖任何单个对象的上下文。
- 它们共同支持在类层面维护全局信息、实现工厂模式、计数器、缓存等设计场景。





## 8.2 const成员函数

它的this指针是`const * const this`

在 C++ 中，给成员函数加上 `const` 后缀，就声明它是一个 **常量成员函数**（const member function）。其核心作用是告诉编译器：**在此函数体内，不会修改对象的任何非 `mutable` 数据成员，也不会调用任何非常量成员函数**。

------

 语法与含义

```c++
struct MyClass {
    int  getX() const {      // 常量成员函数
        return _x;           // 只能读取成员
    }

    void setX(int v) {       // 非常量成员函数
        _x = v;              // 可修改成员
    }

private:
    int _x = 0;
};
```



非const对象可以调用const成员函数和非const成员函数

const对象只能调用const成员函数











# 九.特殊的数据成员

## 9.1 const数据成员

常量数据成员是一个在对象创建时就必须初始化，之后就不能再修改的成员变量

```C++

class Car {
public:
	Car(const string brand, int price) 
		:_brand(brand), // 常量数据成员必须使用初始化列表进行初始化操作
		_price(price)
	{
		cout << "调用构造函数" << endl;
	}

	void Print() {
		cout << "car name: " << _brand << endl;
		cout << "price: " << _price << endl;
	}

#if 0
	void Change() {
		string newbrand = "BYD";
		_brand = newbrand; // ERROR 表达式必须是可修改的左值
	}
#endif
private:
	const string _brand; // 常量数据成员
	int _price;
};

void test1() {
	char temp[15] = "Porsche 911";
	Car c1(temp, 128);
	c1.Print();
}
```

------------

用 const 关键字进行修饰的数据成员，就成为常量成员。一经初始化，该数据成员便具有“只读属性”，在程序中无法对其值修改。在构造函数体内对const 数据成员赋值是非法的，**const数据成员需在初始化列表中进行初始化**（C++11之后也允许在声明时就初始化）。(在C++中, 只有在初始化列表中才是初始化行为; 在成员函数体内是赋值)





## 9.2 引用数据成员

用自己绑定别的数据成员

```C++
class Point {
public:
	Point(int ix, int iy)
		: _ix(ix)
		, _iy(iy)
		, _iz(_ix) //注意这里面的写法，绑定_ix
	{
	}

	void Print() {
		cout << "_ix: " << _ix << endl;
		cout << "_iy: " << _iy << endl;
		cout << "_iz: " << _iz << endl;
	}


	// 注意: 引用成员需要绑定一个已经存在的、且在这个引用成员的生命内始终有效的变量（对象）。
	// 下面这种绑定参数的写法, 因为参数并不在这个引用成员的生命内始终有效, 因此不能这样写
#if 0
	class Point2
	{
	public:
		Point2(int x, int y, int z)
			: _ix(x)
			, _iy(y)
			, _iz(z) //这样绑定可行吗
		{
		}

	private:
		int _ix;
		int _iy;
		int& _iz;
	};
#endif

private:
	int _ix;
	int _iy;
	int& _iz; // 用_iz绑定了数据成员_ix
};

void test() {
	Point p(777,666);
	p.Print();
}
```





------

引用成员需要绑定一个已经存在的、且在这个引用成员的生命周期内始终有效的变量（对象）。



## 9.3.1 对象数据成员

```C++
class Point {
public:
	Point() {}

	Point(int ix, int iy)
		:_ix(ix)
		, _iy(iy)
	{
	}

private:
	int _ix;
	int _iy;
};

class Line {
public:
	Line(int x1, int y1, int x2, int y2)
		//如果没有在Line的构造函数的初始化列表中
		//显示调用Point的构造函数
		//那么会自动调用Point的无参构造
		: _pt1(x1, y1) //相当于Point _pt1(x1,y1)
		, _pt2(x2, y2)
	{
		cout << "Line(int,int,int,int)" << endl;
	}

private:
	Point _pt1;
	Point _pt2;
};

void test() {
	Line L(1, 1, 2, 2);
}
```





-------

**如果在Line类的构造函数的初始化列表中没有显式地初始化Point类对象成员，编译器会自动去调用Point类型的默认无参构造；**

如果不想用Point的无参构造，那么必须在Line类的初始化列表中对Point类的对象成员进行初始化

一个Line对象中包含两个Point对象，称为**成员子对象**。



## 9.3.2 引用对象数据成员

```C++

class Point {
private:
	int _x;
	int _y;

public:
	Point(int x, int y)
		:_x(x)
		, _y(y)
	{
		cout << "Point构造函数" << endl;
	}

	~Point() {
		cout << "Point析构函数" << endl;
	}
	Point(const Point& other)
		:_x(other._x)
		, _y(other._y)
	{
		cout << "Point拷贝构造函数" << endl;
	}
};


class Line {
private:
	//如果不用&引用的方式, 这里面会有拷贝构造函数调用, 造成更多的消耗
	//如果想要避免，这里面直接写引用
	Point& _pt1;
	Point& _pt2;

public:
	//这里面也需要引用，满足拷贝构造函数的调用时机2
	Line(Point& pt, Point& pt2)
		:_pt1(pt)
		, _pt2(pt2)
	{
		cout << "Line构造函数" << endl;
	}

	~Line() {
		cout << "Line析构函数" << endl;
	}
};

void test() {
	Point pt1(1, 2), pt2(3, 5);
	Line line(pt1, pt2);
}

```

------------------



| 特性        | `Point _pt;`（值）        | `Point& _pt;`（引用）          |
| ----------- | ------------------------- | ------------------------------ |
| 存储方式    | 直接存储对象副本          | 存储指向外部对象的引用（指针） |
| 构造 / 析构 | 调用 `Point` 的 ctor/dtor | 不调用 `Point` 的 ctor/dtor    |
| 初始化方式  | 可默认构造或显式初始化    | **必须**在初始化列表中绑定     |
| 赋值可行    | 可拷贝 / 赋值             | 不能改变引用绑定               |
| 内存大小    | `sizeof(Point)`           | `sizeof(void*)`                |







## 9.4 静态数据成员 (类外)

C++ 允许使用 static （静态存储）修饰数据成员，这样的成员在创建对象之前被创建并初始化的。且其实例只有一个，被所有该类的对象共享，就像住在同一宿舍里的同学共享一个房间号一样。

**静态数据成员存储在全局/静态区，并不占据对象的存储空间**。

**静态数据成员被整个类的所有对象共享。**

**静态数据成员要在类外进行初始化。**



``` c++
class Computer {
public:
	//...    
private:
	char * _brand;
	double _price;
    //数据成员的类型前面加上static关键字
    //表示这是一个static数据成员（共享）
	static double _totalPrice;
};
double Computer::_totalPrice = 0;

```

----------------

静态成员规则：

1. private的静态数据成员无法在类之外直接访问（显然）
2. **对于静态数据成员的初始化，必须放在类外**（一般紧接着类的定义，这是规则1的特殊情况）
3. 静态数据成员初始化时不能在数据类型前面加static，在数据成员名前面要加上类名+作用域限定符
4. 如果有多条静态数据成员，那么它们的初始化顺序需要与声明顺序一致（规范）
5. 静态成员在访问时可以通过对象访问，**也可以直接通过类名::成员名的形式**（更常用）

-------------

一个空类占用的大小是1字节

## 9.5 static数据成员

**静态数据成员（static data member）**

1. 定义与特点

    - **属于类本身，而不是任何具体对象。**无论创建多少个该类的对象，静态数据成员在内存中只有一份。
    - 在类内部声明，在类外部（通常在 `.cpp` 文件）定义和初始化。

2. 声明与定义示例

    ```cpp
    // MyClass.h
    class MyClass {
    public:
        static int s_count;      // 声明
        MyClass() { ++s_count; }
        ~MyClass() { --s_count; }
    };
    
    // MyClass.cpp
    #include "MyClass.h"
    int MyClass::s_count = 0;    // 定义并初始化
    ```

3. **访问方式**

    - **通过类名**：`MyClass::s_count`
    - **也可通过对象**：`obj.s_count`（不推荐，易误导）

4. **用途**

    - 维护与类相关的全局状态，比如计数器、配置参数等。
    - 与单例模式配合时，存放全局实例指针等。

5. **注意事项**

    - 静态数据成员不能放在构造函数的初始化列表中初始化，因为它不属于任何对象。
    - 多线程环境下，对静态成员的并发写访问需要同步保护。









# 十.    对象的组织

函数对象

函数对象是一个重载了 **`operator()`** 的类或结构体实例。它看起来像函数一样被调用，但本质上是一个对象

```c++
struct SquareAccumulator {
    // 构造时可以指定初始值
    SquareAccumulator(int init = 0)
      : _sum(init)
    { }

    // 重载 operator()，使实例可像函数一样调用
    void operator()(int x) {
        sum += x * x;
    }

    // 提供一个获取结果的成员函数
    int result() const {
        return sum;
    }

private:
    int _sum;  // 内部状态：累加器
};

void test(){
    vector<int> v = {1, 2, 3, 4, 5};
    // 创建函数对象
    SquareAccumulator acc(10);
    // 可以结合for_each()使用, 对v中的每个元素执行acc(x)
    for_each(v.begin(), v.end(), acc);
}
```





# 十一. 其他

## 10.1 c++风格的字符串

“C++ 风格”的字符串是 `std::string` 类型。它不是一个固定长度的字符数组，而是一个动态管理内存、带有丰富成员函数的类。

--------------

C++字符串有8种方式构建; 有8种方式操作; 有3种方式遍历

```c++
#include <iostream>
#include <string>
using namespace std;

// 有8种方式构建字符串:
void test1() {
	string str1; // 1. 无参构造函数, 生成一个空字符串
	string str2("MTYDMTLL"); // 2. 构造一个字符串并初始化值
	string str3("WGNMSMTBJYDXZDYMTHYJMSI", 3); // 3. 用第一个参数的前3个值构造一个字符串
	string str4(str2); // 4. 拷贝构造一个字符串
	string str5(str2, 4, 3); // 5. 用第一个参数的部分构造字符串(起始位, 长度), 从0开始的
	string str6(5, 'a'); // 6. 构造一个有N个相同字符的字符串
	cout << "str1: " << str1 << endl;
	cout << "str2: " << str2 << endl;
	cout << "str3: " << str3 << endl;
	cout << "str4: " << str4 << endl;
	cout << "str5: " << str5 << endl;
	cout << "str6: " << str6 << endl;

	char arr[17] = "BLMGWDBLMTXLHHHH";	//接收头尾部迭代器，目前阶段就把迭代器理解成指针
	string str7(arr, arr + 3); // 7. 以区间[arr, arr+3)内的字符创建一个String对象
	cout << "str7: " << str7 << endl;

	//begin()返回的是首迭代器, end()返回的是尾后迭代器
	string str8(str2.begin(), str2.end()); // 8. 以区间[begin, end)内的字符创建一个String对象
	cout << "str8: " << str8 << endl;

	cout << "----------------------------------" << endl;
}

// 也同样有8种方式操作字符串:
void test2() {
	string str("MTNB");
	string str2("WBSJS");

	cout << str.data() << endl; // 1. 获取指向字符串的指针
	cout << str.c_str() << endl; // 2. 返回c风格的字符串, 类型const char*
	cout << str.empty() << endl; // 3. 判断是否为空 empty  是返回1否返回0表示有值
	cout << str.size() << endl; // 4. 获取字符数, 不包含结尾的\0
	cout << str.length() << endl; // 5. 跟上面一模一样
	str.push_back('a'); // 6. 字符串结尾追加一个字符
	cout << str << endl;

	// 7. 下面是append函数的重载
	cout << str.append(2, 'h') << endl; // 在字符串的末尾添加N个字符
	cout << str.append(str2) << endl; // 在字符串末尾添加str2
	cout << str.append(str2, 1, 3) << endl; // 在字符串末尾添加str2指定的值[1,3]
	cout << str.append("MTZC") << endl; // 在字符串末尾添加参数
	
	// 8. 下面是find函数的重载
	cout << str.find(str2, 0) << endl; // 从字符串的第N位开始查找字符串str2, 返回位置
	cout << str.find('h', 0) << endl; // 从字符串的第N位开始查找字符, 返回位置
	cout << str.find("BSJS", 0, 2) << endl; // 从字符串指定起始位置查找字符, 查找第一个参数的前2个值, 返回位置

	cout << "----------------------------------" << endl;
}

void test3() {
	string str1 = "MTNB";
	string str2 = "MTZC";
	string str3 = "MTNB";
	
	// 两个字符串可以直接向比较, 1真0假
	cout << (str1 == str2) << endl;
	cout << (str1 == str3) << endl;
	cout << (str1 != str2) << endl;
	cout << (str1 < str2) << endl;
	cout << (str1 > str2) << endl;
	cout << (str1 <= str2) << endl;
	cout << (str1 >= str2) << endl;

	cout << "----------------------------------" << endl;
}

// 有3中遍历string的方法:
// string 是一种存储char型数据的容器, 并再次基础上拓展了丰富的字符串接口
// 因此对字符串的遍历方法和对容器的遍历方法没有什么区别
void test4() {
	string str = "WCSDSLMTBDSLMTZMBQSWCMTZKSYWCYZLABBRDSB";
	
	// 1. 使用平平无奇的for循环下标遍历
	for (size_t i = 0; i < str.length(); i++) {
		cout << str[i];
	}
	cout << endl;

	// 2. 使用增强的平平无奇的for循环遍历
	for (auto& ch : str) { // 定义一个引用变量. 用来接收str中的内容, 减少开销
		if (ch == 'A') {
			ch = 'a'; // 可以直接修改内容, 为了避免可以在auto前加上const
		}
		cout << ch;
	}
	cout << endl;

	// 3. 使用看起来牛逼的迭代器遍历
	// begin函数返回首迭代器 (指向首元素的指针); end函数返回尾后迭代器(指向尾元素的后一位的指针)
	auto head = str.begin();
	while (head != str.end()) {
		cout << *head;
		head++;
	}
	cout << endl;
}

int main() {
	test1();
	test2();
	test3();
	test4();

	return 0;
}

```

```c++
str1:
str2: MTYDMTLL
str3: WGN
str4: MTYDMTLL
str5: MTL
str6: aaaaa
str7: BLM
str8: MTYDMTLL
----------------------------------
MTNB
MTNB
0
4
4
MTNBa
MTNBahh
MTNBahhWBSJS
MTNBahhWBSJSBSJ
MTNBahhWBSJSBSJMTZC
7
5
8
----------------------------------
0
1
1
1
0
1
0
----------------------------------
WCSDSLMTBDSLMTZMBQSWCMTZKSYWCYZLABBRDSB
WCSDSLMTBDSLMTZMBQSWCMTZKSYWCYZLaBBRDSB
WCSDSLMTBDSLMTZMBQSWCMTZKSYWCYZLaBBRDSB
```

----------

迭代器

```C++
//某容器的迭代器形式为 容器名::iterator
//此处auto推导出来it的类型为string::iterator
auto it = str.begin();
while(it != str.end()){
    cout << *it << " ";
	++it;
}
cout << endl;
```

![image-20250608175324290](D:\MarkDown\Picture\image-20250608175324290.png)





## 10.2 C++动态数组vector

```C++
#include <iostream>
#include <vector>
#include <string>
using namespace std;

class Point {
public:
    Point(int x = 0, int y = 0) : _x(x), _y(y) {
        cout << "构造函数: Point(" << _x << ", " << _y << ")" << endl;
    }

    Point(const Point& other) : _x(other._x), _y(other._y) {
        cout << "拷贝构造函数: Point(" << _x << ", " << _y << ")" << endl;
    }

    ~Point() {
        cout << "析构函数: Point(" << _x << ", " << _y << ")" << endl;
    }

private:
    int _x, _y;
};

// Vector的几种创建方式
void test1() {
	vector <int> nums1; // 无参构造
	vector <char> nums2(10, 'x'); // 传入参数指明元素类型和数量
	vector <string> nums3{ "In ", "the ", "beginning ", "hello ", "god ", "created ", "the ", "heaven ", "and ", "the ", "earth" }; // 用列表进行初始化
	vector <string> nums4(nums3.begin(), nums3.end()-2); // 用迭代器进行初始化

    // 一种常见的遍历写法, 利用首元素迭代器和尾后迭代器
    // 剩下的两种遍历方法与string相同,  分别是下标遍历和增强for循环遍历
    auto it1 = nums3.begin();
    auto it2 = nums3.end();
    while (it1 != it2) {
        cout << *it1;
        it1++;
    }
    cout << endl;
}

// Vector容器的9种常用操作
void test2() {
    vector<int> v{ 1, 2, 3, 4 };

    //迭代器的两种写法，均正确
    vector<int>::iterator it1 = v.begin(); // auto it1 = v.begin();
    auto it2 = v.end();

    while (it1 != it2) {
        cout << *it1 << " ";
        ++it1;
    }
    cout << endl;
    cout << "判空`" << v.empty() << endl; //1.判空
    cout << "返回容器中存放的元素个数`" << v.size() << endl; //2.返回容器中存放的元素个数
    cout << "返回容器容量`" << v.capacity() << endl; //3.返回容器容量（最多可以存放元素的个数）
    v.push_back(5); //4.在最后一个元素的后面再存放元素
    cout << "返回容器中存放的元素个数`" << v.size() << endl;
    cout << "返回容器容量`" << v.capacity() << endl; 
    v.pop_back(); //5.删除最后一个元素
    cout << "返回容器中存放的元素个数`" << v.size() << endl;
    cout << "返回容器容量`" << v.capacity() << endl;
    v.shrink_to_fit();  //6.释放多余的空间
    cout << "返回容器中存放的元素个数`" << v.size() << endl;
    cout << "返回容器容量`" << v.capacity() << endl;
    cout << "判空`" << v.empty() << endl; //判空
    v.clear(); //7.清空所有元素，但不释放空间
    cout << "返回容器中存放的元素个数`" << v.size() << endl;
    cout << "返回容器容量`" << v.capacity() << endl;
    cout << "判空`" << v.empty() << endl; //判空
    v.shrink_to_fit();  //8.释放多余的空间
    cout << "返回容器中存放的元素个数`" << v.size() << endl;
    cout << "返回容器容量`" << v.capacity() << endl;
    cout << "判空`" << v.empty() << endl; //判空
    v.reserve(10); //9.申请空间，不存放元素
    cout << "返回容器中存放的元素个数`" << v.size() << endl;
    cout << "返回容器容量`" << v.capacity() << endl;
    cout << "判空`" << v.empty() << endl; //判空
}

// 使用自定义对象创建Vector容器
void test3() {

    vector<Point> nums;

    // nums.reserve(10); // 注释后观察容量变化与拷贝构造次数
    /*
        不调用 reserve() 的时候：
        vector 容器的容量会 自动增长（通常是2倍扩容）。
        当容量不够时，会进行 扩容 + 元素拷贝，频繁调用拷贝构造函数。

        调用 nums.reserve(10);：
        提前分配好足够的空间（10个 Point）。
        后续 push_back 不再引起扩容，也不会导致已有元素的拷贝。
        构造函数调用次数变少，性能更高。
    */

    nums.push_back(Point(1, 2));
    cout << "Size: " << nums.size() << ", Capacity: " << nums.capacity() << endl;

    nums.push_back(Point(3, 4));
    cout << "Size: " << nums.size() << ", Capacity: " << nums.capacity() << endl;

    nums.push_back(Point(5, 6));
    cout << "Size: " << nums.size() << ", Capacity: " << nums.capacity() << endl;

    nums.push_back(Point(7, 8));
    cout << "Size: " << nums.size() << ", Capacity: " << nums.capacity() << endl;

}

int main() {
    test3();
	return 0;
}
```

----------------

vector常用的几种构造形式：

（1）无参构造，仅指明vector存放元素的种类，没有存放元素；

``` c++
vector <int> numbers;
```

（2）传入一个参数，指明vector存放元素的种类和数量，参数是存放元素的数量，每个元素的值为该类型对应的默认值；

``` c++
vector<long> numbers2(10); //存放10个0
```

（3）传入两个参数，第一个参数为vetor存放元素的数量，第二个参数为每个元素的值（相同）；

``` c++
vector<long> numbers2(10，20); //存放10个20
```

（4）通过列表初始化vector，直接指明存放的所有元素的值

``` c++
vector<int> number3{1,2,3,4,5,6,7};
```

（5）迭代器方式初始化vector，传入两个迭代器作为参数，第一个为首迭代器，第二个为尾后迭代器；

``` c++
vector<int> number3{1,2,3,4,5,6,7};
vector<int> number4(number3.begin(),number3.end() - 3);//推测一下，number4中存了哪些元素

int arr[5] = {1, 2, 3, 4, 6};
vector<int> number5(arr, arr + 5)
```

-----------

vector的常用操作

```c++
iterator begin();  //返回首位迭代器
iterator end();  //返回尾后迭代器

bool empty() const; //判空

size_type size() const; //返回容器中存放的元素个数
size_type capacity() const; //返回容器容量（最多可以存放元素的个数）

void push_back(const T& value); //在最后一个元素的后面再存放元素
void emplace_back( Args&&... args );//在最后一个元素的后面构造一个新的对象，只需要传递需要创建对象的构造函数参数即可

void pop_back(); //删除最后一个元素
void clear(); //清空所有元素，但不释放空间
void shrink_to_fit();  //释放多余的空间

void reserve(size_type new_cap);//申请空间，不存放元素
```

----

Vector的三种遍历方式

```c++
void test2(){
    //下标方式遍历
    vector<int> nums = {1, 2, 3, 4, 5};
    for(size_t idx = 0; idx < nums.size(); ++idx){
        cout << nums[idx] << " ";
    }
    cout << endl;

    //增强for循环遍历
    for(auto & ele : nums){
        cout << ele << " ";
    }
    cout << endl;

    //迭代器方式遍历
    auto it = nums.begin();
    while(it != nums.end()){
        cout << *it << " ";
        ++it;
    }
    cout << endl;
}
```

------

vector的动态扩容

当vector存放满后，仍然追加存放元素，vector会进行自动扩容。

vim上vector是2倍的容量扩容机制：当vector存满后再添加新的元素，容量就会变成2倍，把新的元素存入其中。

VS上是1.5倍的扩容—— 很多技术上具体的实现，在不同的平台上细节不同。C++标准给出功能的要求，各个编译器只需要实现此功能。



其工作步骤如下：

（1）开辟空间（2）Allocator分配（后面STL阶段学习）（3）复制，再添加新元素（4）回收原空间

<img src="D:\MarkDown\Picture\undefined202403111142666.png" alt="image-20240311114245592" style="zoom:67%;" />

### 

--------------

vector的底层实现（重点*）

利用sizeof查看vector对象的大小时，发现无论存放的元素类型、数量如何，其大小始终为24个字节（64位环境）

**因为vector对象是由三个指针组成**

<img src="D:\MarkDown\Picture\image-20231009161203935.png" alt="image-20231009161203935" style="zoom:80%;" />

<span style=color:red;background:yellow>**_start指向当前数组中第一个元素存放的位置**</span>

<span style=color:red;background:yellow>**_finish指向当前数组中最后一个元素存放的下一个位置**</span>

<span style=color:red;background:yellow>**_end_of_storage指向当前数组能够存放元素的最后一个空间的下一个位置**</span>



可以推导出

size() :  _finish 减 _start

capacity():  _end_of_storage 减 _start

