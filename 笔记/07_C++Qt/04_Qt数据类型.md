# 基本数据类型

兼容C/C++中的所有数据类型, 但是在Qt中多了一个浮点类型qreal

## 1. 1: 字符串类型

```c++
// C
char arr[10];
char *pstr = "Man";
// C++
const char *pstr = "Man";
string str("Man");;
// Qt
QString
QByteArray
```

`QString`类：用于==**存储和操作Unicode字符串**==。它支持字符串的连接、截取、替换、查找等操作，并提供了丰富的转换函数用于不同编码之间的转换。QString是Qt中的字符串类，与C/C++不同的是，不再使用ASCII编码，而使用Unicode编码。因此一个字符不是8位的char，而是16位的QChar，这就是为什么之前一个汉字占用一个字符的原因。

### 隐式共享

QString的底层采用的是隐式共享(写时复制)



`QByteArray`类：==**处理原始字节数据**==，用于存储和操作字节数组，本质是一个动态字节数组。它可以用于处理二进制数据或者文本数据的字节表示。



### 格式化输出

可 以用%1 %2 这种方法实现格式化输出





# Qt的容器 

## 一: 序列式容器

QVector

和STL中的Vector不同, ==QVector在内部使用连续的内存块来存储元素==, 适合频繁随机访问的情况

QLinkedList

QList (deque), 底层实现基于动态数组, 在一个块大小之内是数组, 超过了一个块的大小就是链表, ==会根据元素大小和数量选择最优的存储策略==(可能是数组或者链表)

QStack是栈容器(LIFO), QQueue是队列容器(FIFO), 两者基于QList





## 二: 关联式容器

QMap提供一个字典(关联数组), 一个键对应一个值(键值对), QMap存储数据是按照键的顺序, 键唯一, 每个键对应一个值. 底层采用红黑树结构, 也就是==键唯一不能重复, 并按照key值进行升序排列==

QMultiMap, key值不唯一可重复, 并按照key值进行升序排列



## 三: 无序关联式容器

QSet基于哈希表, 仅存储不重复的元素, 无序, 内部由QHash实现, 只存不重复的元素

QHash是基于散列表来实现字典功能的模板, QHash<QKey, T>

QMultiHash存放键值对, key值不唯一, 可以重复, 元素无序